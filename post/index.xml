<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Idiomatic Go</title>
    <link>http://idiomaticgo.com/post/index.xml</link>
    <description>Recent content in Post-rsses on Idiomatic Go</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Nov 2016 10:30:10 +0000</lastBuildDate>
    <atom:link href="http://idiomaticgo.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Accept interfaces return structs</title>
      <link>http://idiomaticgo.com/post/best-practice/accept-interfaces-return-structs/</link>
      <pubDate>Wed, 02 Nov 2016 10:30:10 +0000</pubDate>
      
      <guid>http://idiomaticgo.com/post/best-practice/accept-interfaces-return-structs/</guid>
      <description>&lt;p&gt;I have heard mentioned several times this idea of accepting interfaces and returning structs.
Here I will try to outline why I think this is good practice.&lt;/p&gt;

&lt;p&gt;When writing packages our goal is for them to be consumed by someone. Either by our own code, but also, hopefully, by others too.
We want to make this as simple and frictionless as possible and avoid causing frustration for the consumers of our packages.
Accepting interfaces and returning structs can be a powerful way to achieve this.
It allows the consumers of our packages to reduce the coupling between their code and yours. It also makes it
easier to write tests for their code that depend on your package. Lets look at some examples.&lt;/p&gt;

&lt;p&gt;First lets look at what happens when we accept a type specific to our package in the exposed API and then return an interface we have defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package rest

type Config struct{
    Host string 
    Port int32
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package client

import &amp;quot;github.com/someone/rest&amp;quot;

type Client interface{
    DoSomething()error
    DoSomethingMore()error
    ThisIsDoingSomething()error
}

func NewClient(c rest.Config)Client{
    /// init and return a client
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could argue that the config and the client should be in the same package and you would probably be right, but this is just a contrived example to illustrate the point.
Now someone consuming our code has to do some extra work when testing and also rely on not only the &lt;code&gt;client&lt;/code&gt; package but also the &lt;code&gt;rest&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package mywebsite

import(
    &amp;quot;github.com/someone/client&amp;quot;
    &amp;quot;github.com/someone/rest&amp;quot;
)

func SomeFunc(c client.Client)error{
    
    return c.DoSomething()
}

func main (){
    c := client.NewClient(rest.Config{
        Host:&amp;quot;ahost&amp;quot;,
        Port:3000,
    })
    SomeFunc(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we mentioned how this pattern effect tests. How does this effect tests? Well because we returned an interface that we defined,
the consumer is now forced to implement every method on that interface rather than just the ones they care about:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//test my service with a mock client 

package mywebsite_test

import &amp;quot;github.com/me/mywebsite&amp;quot; 

type mockClient struct{}
//notice we have to implement all the methods rather than just the one we use.

func (mockClient)DoSomething()error{
    return nil
}
func (mockClient) DoSomethingMore()error{
    return nil
}
func (mockClient)ThisIsDoingSomething()error{
    return nil 
}

func TestSomeFunc(t *testing.T){
    if err := mywebsite.SomeFunc(mockClient{}); err != nil{
        t.Errorf(&amp;quot;did not expect an error but got %s &amp;quot;, err.Error())
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets change our implementation to accept intefaces and return structs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package client

type ClientConfig interface{
    Host()string 
    Port()int32
}

type Client struct{ 
    config ClientConfig
}

func (c *Client)DoSomething()error{
    //do some work ...
    return nil 
}
//imagine more methods

/// New inits and returns a client
func New(c ClientConfig)*Client{
    return &amp;amp;Client{
        config: c,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now our implementation has changed lets see the impact we have on the consumers of our code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package mywebsite

import(
    &amp;quot;github.com/someone/client&amp;quot; //Only one import now
)

type clientConfig struct{ }

func (cc clientConfig)Host()string{
    return &amp;quot;ahost&amp;quot;
}

func (cc clientConfig)Port()int32{
    return 3000
}

// Consumer can now define an interface that our struct fulfills but that only has one method.
type Client interface{
    DoSomething()error 
}

func SomeFunc(c Client)error{
    
    return c.DoSomething()
}

func main (){
    c := client.New(&amp;amp;clientConfig{})
    SomeFunc(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now there is only one import from our package reducing our footprint on the consumer&amp;rsquo;s code. But more importantly, because we returned a struct,
the consumer of the code can define their own interface with just the methods they care about. Lets look at our test code now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//test my service with a mock client 

package mywebsite_test

import &amp;quot;github.com/me/mywebsite&amp;quot; 

type mockClient struct{}
//notice we have to implement ONLY the method we use now.

func (mockClient)DoSomething()error{
    return nil
}

func TestSomeFunc(t *testing.T){
    if err := mywebsite.SomeFunc(mockClient{}); err != nil{
        t.Errorf(&amp;quot;did not expect an error but got %s &amp;quot;, err.Error())
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The boiler plate in the test is vastly reduced as only one method had to be mocked rather than three.
Hopefully I have shown the benefit of accepting interfaces and returning structs here and it will inspire you to
make use of this pattern in your own code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Idiomatic go tests</title>
      <link>http://idiomaticgo.com/post/testing/idiomatic-go-tests/</link>
      <pubDate>Sun, 16 Oct 2016 10:20:44 +0100</pubDate>
      
      <guid>http://idiomaticgo.com/post/testing/idiomatic-go-tests/</guid>
      <description>

&lt;p&gt;What does it mean to write idiomatic go tests? I will outline what it means to me and try to convey through details and examples what I wish I had known when starting out with Go.&lt;/p&gt;

&lt;h3 id=&#34;idiomatic-go-tests-are-written-using-the-builtin-testing-package&#34;&gt;Idiomatic go tests are written using the builtin testing package&lt;/h3&gt;

&lt;p&gt;Go comes with a builtin &lt;a href=&#34;https://golang.org/pkg/testing/&#34;&gt;testing&lt;/a&gt; package. There is no need for an external testing package. Although these do exist and it is not for me to say you shouldn&amp;rsquo;t use them.
However I would encourage writing tests using the builtin testing package, and only when you begin to feel it is failing you somehow, look at what external packages can offer.&lt;/p&gt;

&lt;p&gt;Tests in a Go program are normally defined along with the source code for the package. Notice below that the test file is named &lt;code&gt;*_test.go&lt;/code&gt; Go expects your tests to be named this way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myPkg
├── repo.go
├── repo_test.go

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The testing package is built to be used with the &lt;code&gt;go test&lt;/code&gt; command. It looks for tests that are defined in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestXxx(*testing.T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets look at a very simple example the first file is &lt;code&gt;sum.go&lt;/code&gt; and the second file &lt;code&gt;sum_test.go&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package myPkg  

Sum(a,b int)int{
    return a + b
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we have our test for this package. Things to notice here include the package name and the test name:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum_test.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package myPkg_test //notice we name it _test this allows us to work only with the exported api of our package.

import &amp;quot;testing&amp;quot;
import &amp;quot;github.com/maleck13/myPkg&amp;quot;

func TestSum(t *testing.T){
    if 3 != myPkg.Sum(1,2){
        t.Fatalf(&amp;quot;expected the sum to equal %d&amp;quot;,3)
    } 
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Somethings worth pointing out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In our test the package name is &lt;code&gt;package_test&lt;/code&gt; this is a convention in Go. It allows the test file to be in the same package as the source code, but only have access to the
exported types, and functions etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Notice that in our test, we do not have an inbuilt assert. Read the code again, notice that there is very little different
in how our test code reads compared with our business logic code, it is just more Go code. This is intentional. It may mean you write a few more lines of code,
but has the advantage of allowing anyone who knows Go to be able to read and modify your test code without the overhead of
learning a testing DSL.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;mocks-and-stubs&#34;&gt;Mocks and Stubs&lt;/h3&gt;

&lt;p&gt;Mocks are used frequently in Go tests. The most common way you will see a mock used is to provide a different implementation of a required interface. Mocks can be stored anywhere in your test code, but often they would be stored
under a mock or test package.  Lets look at an example of mocking in Go.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package mything

type Doer interface{
    Do()error 
}

func BusinessDoer (d Doer)error{
    //some business logic 
    return d.Do()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now our test file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package mything_test 

import mything

//This mock could be in a separate file.

type mockDoer struct{
    Error error 
}
// implment our Doer iterface
func(md mockDoer)Do()error{
    return md.Error
}

func TestBusinessDoer(t *testing.T){
    doer := mockDoer{}
    if err := mything.BusinessDoer(doer); err != nil{
        t.Fatalf(&amp;quot;did not expect an error but got %s&amp;quot;,err.Error())
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in our test we have swapped out the original implementation of the Doer interface for our own implementation that we can easily
control the behaviour of. It is important that if you want to unit test your code, that you express the dependencies used by that piece of code
as an interface as this will allow for simple mocking. It is also a good reason to aim to keep your interfaces small. The smaller the interface the
less work it is to mock out.&lt;/p&gt;

&lt;h3 id=&#34;table-driven-tests&#34;&gt;Table driven tests&lt;/h3&gt;

&lt;p&gt;In the above example we defined a test that tested some business logic for one case where the business logic
does not return an error. Normally we would also want to at least test one other case, the case where the the dependency does
return an error. Now we could define a new test entirely for this, however often in Go code you will see an approach for this called table testing.
Lets look at an example that expands on the first example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package mything

type Doer interface{
    Do()error 
}

func BusinessDoer (d Doer)error{
    //some business logic 
    return d.Do()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now our test file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package mything_test 

import mything

//This mock could be in a separate file.

type mockDoer struct{
    Error error 
}
// implment our Doer iterface
func(md mockDoer)Do()error{
    return md.Error
}

func TestBusinessDoer(t *testing.T){
    cases := []struct{
        Name string
        ExpectError bool 
        Error error
    }{
        {
            Name:&amp;quot;test does business logic&amp;quot;,
            ExpectError : false,
            Error : nil,
        },
        {
            Name:&amp;quot;test fails when dependency errors&amp;quot;,
            ExpectError : true,
            Error : errors.New(&amp;quot;an error&amp;quot;),
        },
    }

    for _,td := range cases{
        t.Run(td.Name, func (t *testing.T){
            doer := mockDoer{Error: td.Error}
            err := mything.BusinessDoer(doer) 
            if td.ExpectError &amp;amp;&amp;amp; err == nil{
                t.Fatalf(&amp;quot;expected an error but got none&amp;quot;)
            } 
            if ! td.ExpectError &amp;amp;&amp;amp; err != nil{
                t.Fatalf(&amp;quot;did not expect an error but got one %s &amp;quot;, err.Error())
            }
        })
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we are defining a set of test cases in a slice. We are defining some inputs and expected behaviour. Then we are ranging over each of these
tests cases and running them in a separate sub test. Sub tests allow us to re run a single failing test case rather than them all. In the above case if
you wanted to run the sub test &lt;code&gt;test fails when dependency errors&lt;/code&gt; you would do so by running the following command from within the package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go test -run TestBusinessDoer/test_fails_when_dependency_errors

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>